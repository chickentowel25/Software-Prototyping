# Ghost Chase

**Name:** Yewon Kim  
**Student ID:** 20253158  
**Repository URL:** http://git.prototyping.id/20253158/homework5

---

## üìë Table of Contents
1. [Game Concept & Mechanics](#1-game-concept--mechanics)
2. [Game Elements & Implementation](#2-game-elements--implementation)
3. [Expected Challenges](#3-expected-challenges)

---

## 1. Game Concept & Mechanics

**Ghost Chase** is a multiplayer maze attack game where two players **co-control** a single character to escape the maze (dungeon).

> ‚ÄúYou‚Äôre not just escaping the maze. You‚Äôre escaping the traces of your past.‚Äù

### üéØ Goal
- Solve the maze and reach the exit of the dungeon, avoiding obstacles.
- Avoid ghost clones that **replay your previous failed attempts**.
- Survive each level as new ghost clones stack up.

### üïπÔ∏è Controls & Interactions

| Player | Controls       | Role                          |
|--------|----------------|-------------------------------|
| 1      | `A`, `W`, `D`   | Controls **direction**         |
| 2      | `‚Üí` to move, `‚Üë/‚Üì` to change speed ranging from 1~5 | Controls **movement and throttle** |

**Win Condition:**  
- Reach the exit before getting caught by any ghost.

**Lose Condition:**  
- Hit an obstacle, or collide with a ghost (your past self).

---

## 2. Game Elements & Implementation

### üåê Game World

- Bottom-up maze with walls and traps, ending with an exit to outside.
- One player icon, followed by its ghost clones (# of retries).
- UI overlays (level, # of retries, speed of player).
- Concept diagram:
  <p>
  <img src="./src/assets/concept-diagram.png" height="400"/>
  </p>


### üñºÔ∏è Reference Images

- Ghost Chase would resemble the logic and visuals of maze attack games like Pacman.

  <p>
  <img src="./src/assets/pacman.jpg" height="200"/>
  <img src="./src/assets/fireBoyAndWatergirl.png" height="200"/>
  </p>

### üîß Architecture

#### üì¶ Tentative Folder Structure

```plaintext
ghost-chase/
‚îú‚îÄ‚îÄ public/                   
‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/           # Svelte UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Canvas.svelte     # Imports game p5 sketch
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ HUD.svelte        # Level info, retries, speed
‚îÇ   ‚îú‚îÄ‚îÄ game/                 # Game logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gameLoop.js       # Initialize, update and render game
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ player.js         # Player input + drawing player sprite
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ghost.js          # Ghost clone management + drawing ghost sprite
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ maze.js           # Maze structure + drawing
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controls.js       # Key mappings
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ recorder.js       # Records player path
‚îÇ   ‚îú‚îÄ‚îÄ App.svelte            # Roots Svelte components
‚îÇ   ‚îú‚îÄ‚îÄ main.js               
‚îÇ   ‚îî‚îÄ‚îÄ styles.css
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ vite.config.js            
‚îî‚îÄ‚îÄ README.md
```

#### üß± Modules and Libraries

- Each game module inside `/src/game/` encapsulates a single responsibility so that logic stays separated from the UI. 
- `Canvas.svelte` imports and orchestrates these modules through a p5 sketch loop (`setup`, `draw`), calling `gameLoop.js`, which delegates control to modules like `player.js`, `ghost.js`, and `maze.js`.
- UI state (level, # of retries, speed of player) is exposed via reactive Svelte stores and displayed using `HUD.svelte`.
- Libraries used:
  - **[`p5.js`](https://p5js.org/):** Rendering the maze, animations, and character movement  
  - **[`Svelte`](https://svelte.dev/):** Framework putting together UI components
  - **[`Ramda`](https://ramdajs.com/):** Functional utilities for ghost behavior composition, frame transformation pipelines, and immutable game state

#### üåÄ Recursive Function for Ghost Replay

This is the recursive structure behind the system:  
> "To render Run N, first render all ghosts from Run N-1... down to Run 1."

```pseudo
function replayGhostSet(ghostRuns, index = 0):
    if index >= length of ghostRuns:
        return

    currentGhostData = ghostRuns[index]
    replaySingleGhost(currentGhostData)

    replayGhostSet(ghostRuns, index + 1)
```

What‚Äôs Happening:

- `ghostRuns` is an array of player movement histories from each failed attempt.
- Each call **spawns one ghost** and starts replaying it.
- The function **recursively steps through the run history**, ensuring all ghosts from previous tries are loaded into the current level.

To replay each ghost's movement, another recursive function steps through each stored frame:

```pseudo
function replayGhostPath(frameList):
    if frameList is empty:
        return

    set ghost state to first frame
    delay
    call replayGhostPath with remaining frames
```

This allows ghost clones to:

- Move in sync with past runs  
- Be layered recursively as the game progresses  
- Operate independently from player logic using stored frame data  



---

## 3. Expected Challenges

- Ghost logic: replaying previous frames accurately with recursive logic
- Collision and timing issues with multiple ghosts
- Handling performance/memory with repeated clone storage
- Keeping the gameplay balanced (not too easy or impossible after many retries)
- Syncing ghost position and player state updates cleanly in each frame
